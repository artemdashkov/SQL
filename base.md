- [Теория. Определения.](#теория-определения)
- [Типы данных в SQL](#типы-данных-в-sql)
- [Запросы](#Запросы)
    - [SELECT](#select-таблицы)
    - [WHERE](#WHERE)
    - [HAVING](#HAVING)
    - [ORDER BY](#order-by---сортировка-данных)
    - [LIMIT И OFFSET](#LIMIT-И-OFFSET---ограничения)
    - [LIKE](#LIKE)
    - [DISTINCT](#DISTINCT)
    - [GROUP BY](#GROUP-BY)
    - [EXISTS](#EXISTS)
    - [EXTRACT](#EXTRACT)
    - [INSERT](#INSERT)
- [Математические функции](#Математические-функции)
- [Агрегатные функции](#Агрегатные-функции)
- [Связи](#Связи)
- [JOIN](#JOIN)


# Теория. Определения.

**База данных** — это организованная структура для хранения, изменения и обработки взаимосвязанной информации. Обычно базы данных используют для взаимодействия с большими объёмами данных. Практически ни одна большая компания (от интернет-магазинов до банков) сейчас не обходится без использования баз данных.

**КАКИЕ БАЗЫ ДАННЫХ СУЩЕСТВУЮТ?**
- Реляционные базы данных: В них данные хранятся в виде связанных таблиц. Три кита: связи, таблицы, структура.
- Нереляционные базы данных: В них данные хранятся иначе, например в формате ключ-значение или в виде дерева

**Система Управления Базами Данных (СУБД, DBMS — DataBase Management System)** — это комплекс программных средств, необходимых для создания структуры новой базы, ее наполнения, редактирования содержимого и отображения информации.

**SQL (Structured Query Language)** - язык запросов применяется для создания, модификации и управления данными. Для работы с данными, хранящимися в БД, используется специальный язык — SQL.

**СУБД бывают разные**, и языки для них тоже отличаются, являясь диалектами SQL. Наиболее распространенными СУБД являются:
- MySQL,
- PostgreSQL,
- Oracle,
- Microsoft SQL Server.
Для очень большого объёма данных также используют ClickHouse, Hadoop и другие СУБД.

**Что такое реляция (отношения):**
1. Реляция — это связь между таблицами в реляционной базе данных.
2. Она реализуется через внешние ключи (foreign keys) и позволяет организовать данные в связанную структуру.

**Таблица** — это совокупность связанных данных, хранящихся в структурированном виде в БД. Она состоит из столбцов и строк.
**Строка** - набор данных связанных с одним объектом
**Колонка/ столбец** - набор однотипных данных по разным объектам
**В реляционных БД таблица** — это набор элементов данных (значений), использующий модель вертикальных столбцов (имеющих уникальное имя) и горизонтальных строк.
**Ячейка** — место, где строка и столбец пересекаются. Таблица содержит определенное число столбцов, но может иметь любое количество строк.
**Первичный ключ** — это подмножество столбцов, которое уникально идентифицирует строку. Часто в качестве первичного ключа берут просто ID объекта, например, ID пользователя или ID покупки.
**Схемы** — это способ группировки таблиц. это пространство в БД, объединяющее в себе таблицы и другие объекты, относящиеся к одному бизнес-процессу, источнику или пользователю в зависимости от архитектуры системы. Если проводить аналогию с файловой системой, то схема близка к папке, в которой лежат вложенные объекты (при этом внутри нее не может быть других папок).
**Первичный ключ** - уникальный индентификатор строки. По нему можно вытянуть строку. Подмножество столбцов, которое уникально идентифицирует строку. Часто в качестве первичного ключа берут просто ID объекта, например, ID пользователя или ID покупки.
**Внешний ключ** — это столбец или сочетание столбцов, значения которых соответствуют первичному ключу в другой таблице. Выражаясь простыми словами, это ссылка в одной таблице на запись в другой. В «боевых» базах данных и первичные, и внешние ключи стараются делать численными, чтобы их было проще сравнивать, так как компьютеру проще сравнить число с числом, чем тексты или другие типы данных.

**Нормализация база данных (нормальные формы БД)** - это процесс организации данных в базе данных таким образом, чтобы уменьшить избыточность и улучшить целостность данных. Это достигается путем разделения базы данных на таблицы и определения отношений между ними.

**Лайфхаки**
- называть поля тем, чем они являются - использовать существительные
- первичные ключи лучше называть с наименованием таблицы + id, например: `productid`
- `information_schema.tables` — это список всех таблиц.

### Alias
Alias - обращение к полям таблицы (ссылка), используется для упрощения синтаксиса.
```sql
SELECT c.customername, o.ordernumber
FROM ordersum o
JOIN customer c
        ON c.customerid = o.customerid
```
```sql
select 
    c.city_id, 
    c.city_name, 
    c.state, 
    c.population, 
    c.area 
from 
    city as c
where
    c.city_id = 104
```


3. Примеры отношений: один-к-одному, один-ко-многим, многие-ко-многим.

```sql
-- получить все данные из таблицы city схемы sql
SELECT *
FROM sql.city
```
- `SELECT` - отвечает за то, какие колонки будут выбираться из данных.
- `*` - означает всё, т.е. выбрать все
- `FROM` -откуда, из какой таблицы эти данные.
- `sql` - название схемы
- `city` - название таблицы
- `,` - обязательный знак при перечислении
- `--` - комментировать строку
- `/* */` - если нужно закомментировать большой кусок
- `WHERE` -фильтрацию строк в данных

**Структура запроса в SQL**:
- ВЫБЕРИ (SELECT) колонки column_names
- ИЗ (FROM) ТАБЛИЦЫ table_name,
- ДЛЯ СТРОК КОТОРЫХ ВЫПОЛНЕНЫ УСЛОВИЯ (WHERE) conditions.

Для численных типов данных в SQL используются традиционные арифметические операторы:
- `+`	- Сложение
- `-`	- Вычитание
- `*`	- Умножение
- `/`	- Деление
- `%`	- Остаток от деления
Пример:
```sql
select 3/5; -- >>> 0
select 3./5; -- >>> 0.6000000
select 2+3; -- >>> 5
select 2.0 + 3.0; -- >>> 5.0
select (2+2)*2 -- >>> 8
```

### Ситуация с делением на 0
Такая ситуация может возникать довольно часто. Чтобы СУБД не возвращала ошибку, а просто на место деления на 0 ставила NULL (отсутствие значения), существует функция NULLIF(expr1, expr2). Эта функция при равенстве expr1и expr2возвращает NULL, а иначе — expr1. Пример использования:
```sql
select book_id, book_average_rating/NULLIF((book_id - 20.), 0)
from books
```

### Порядок выполнения операторов
1. FROM: первым шагом является определение таблиц, задействованных в запросе.
2. JOIN: следующим шагом является выполнение операции объединения на основе условия объединения.
3. WHERE: прмиенить условие фильтрации к объединенной таблице
4. HAVING: фильтрация групп по условию
5. SELECT: выбор столбцов и агрегатных функций из каждой группы
6. ORDER: сортировка строк по указанным столбцам
7. LIMIT: пропустить несколько строк из отсортированного набора результатов


# Типы данных в SQL
- первичный ключ (`INT PRIMARY KEY AUTO_INCREMENT`) - Для описания ключевого поля. Это значит, что в поле будут заноситься различные целые числа, при этом они будут автоматически генерироваться (каждая следующая строка будет иметь значение ключа на 1 больше предыдущего)
- `serial` — используется для создания первичных ключей таблицы (обычно для создания ID строки). Он очень удобен, так как при добавлении строк в таблицу сам проставляет им уникальный ID на 1 больше, чем предыдущий проставленный ID;
- `integer` (`INT`, `INTEGER`) — используется для больших чисел, Целое число, могут принимать значения от -2 147 483 648 до 2 147 483 647;
- `numeric` (`DECIMAL	`, `NUMERIC`) — он особенно рекомендуется для хранения денежных сумм и других величин, где важна точность; Вещественное число,
в скобках указывается максимальная длина числа (до запятой - сколько максимум цифр в целом числе; после запятой - кол-во цифр после запятой) `DECIMAL(4,1)`; `NUMERIC(6,3)` => 1234,1: 123456,123
- `real` — подходит для чисел, где хорошая точность не очень нужна.
- `bool` - бинарный тип данных bool, данные в котором хранятся в виде `true` или `false`
- `json` - В json данные хранятся в формате `key` : `value`.
- `символьные`
    - `character varying(n)`, `varchar(n)` (`VARCHAR`) — строка ограниченной переменной длины, для коротких строк (до 255 символов), в скобках указывается максимальная длина строки, которая может храниться в поле VARCHAR(10)
    - `character(n)`, `char(n)`	— строка фиксированной длины, дополненная пробелами
    - `text` — строка неограниченной переменной длины, для строк, длина которых заранее не известна, но известно, что она может быть больше 255 символов.

Самые распространенные символьные типы данных:
   - `varchar` для коротких строк (до 255 символов)
   - `text` для строк, длина которых заранее не известна, но известно, что она может быть больше 255 символов.
Например, для таблиц с информацией о пользователях используют тип данных varchar для имени пользователя, а text для хранения графы «О себе» пользователя.

Для обозначения символьных типов данных используют одинарные кавычки, например, так: SELECT 'Hello, world!'.
Двойные кавычки же используют, когда используют название колонок, в котором есть пробелы, либо символы из другого языка, либо когда они конфликтуют с ключевыми словами СУБД. Например:
```sql
select 1 as "SELECT", 'hi' as "Название с пробелом";
```

**Типы данных для даты и времени:**
- timestamp [ (p) ] [ without time zone ]	8 байт	дата и время (без часового пояса)	1 микросекунда / 14 цифр	2019-3-1 12:00:00'
- timestamp [ (p) ] with time zone	8 байт	дата и время (с часовым поясом)	1 микросекунда / 14 цифр	2019-3-1 12:00:00+2'
- date (`DATE`)	Дата в формате ГГГГ-ММ-ДД, `2020-07-26`
- time [ (p) ] [ without time zone ]	8 байт	время суток (без даты)	1 микросекунда / 14 цифр	12:00:00'
- time [ (p) ] with time zone	12 байт	только время суток (с часовым поясом)	1 микросекунда / 14 цифр	12:00:00+2
- interval [ поля ] [ (p) ]	16 байт	временной интервал	1 микросекунда / 14 цифр	interval '2 years'

- bool - бинарный тип данных,данные в котором хранятся в виде true или false. 
- json. В json данные хранятся в формате key : value
- и любые другие пользовательские типы

## Работа с типами данных
```sql
select 2.13::int; --Перевод real в int >>> 2
select '2018-3-1'::date; --Перевод строки в дату >>> март 1, 2018
select true::int::numeric; --Перевод bool в int, а потом в numeric >>> 1
```

Также однотипные данные можно сравнивать друг с другом (например, int и numeric, text и varchar, timestamp и date)
```sql
select 2 = 3; --false
select 3 < 5; --true
select 'hi' != 'hello'; --true
select 3 >= -23; --true
```

Такие же операторы равенства и неравенства можно использовать и для сравнения однотипных данных в столбцах:
```sql
select author = book_name as author_book
from books;
```


# Запросы
## SELECT Таблицы

```sql
-- получить данные только по колонками city_id и city_name таблицы city схемы sql
SELECT city_id
, city_name --рекомендуется запятые переносить на строку, т.к. удобно исключать элемент путем комментирования 
FROM sql.city
```

```sql
SELECT city_id
, city_name
, state
, population - 50052 as populationWOfans -- выведет результат вычитания 'population - 50052' в колонке populationWOfans
, population/area as populationDensity -- выведет результат деления одного столбца на другой в каждой строке
, population/nullif((area-3), 0) as densityWO3m2 --выведет null если результат вычитания равен 0. для других случаев выведет значение
, area
FROM sql.city c
```

NULLIF(expr1, expr2). Эта функция при равенстве expr1 и expr2 возвращает NULL, а иначе — expr1. 

## WHERE
используется для фильтрации данных, указывается после `FROM`
```sql
SELECT *
FROM [table]
WHERE [bool - ДА/НЕТ] AND [bool2 - ДА/НЕТ] OR [bool3 - ДА/НЕТ]
```
- `WHERE` - ГДЕ. SQL будет проверять каждую строчку на предмет 'да' или 'нет'. Можно добавить любую длину условий, которые соединяются ключевым словом 'AND' или 'OR'

=, <>, !=, <, >, <=, >=, BETWEEN [1] AND [2], NOT, IS
- `<>`, `!=` - не равно можно записывать разными способами
- `NOT` - логическое НЕ 
- `IS` - используется для Null, так как NULL в принципе нельзя ни с чем сравнить, то в запросах сравнения он не выводится.
- `BETWEEN [1] AND [2]` - включает границы

```sql
SELECT city_name
, state
FROM sql.city
WHERE area <= 3
```

```sql
-- оператор BEETWEEN
book_average_rating between 3 and 4 -- это то же самое, что и
book_average_rating >= 3 and book_average_rating <= 4

-- ОПЕРАТОР NULL
select * 
from books 
where language_code is null;

-- отрицание условия
where book_average_rating < 4 -- это то же самое, что и
where not book_average_rating >= 4
```
### Кортеж
В случае реляционных БД кортеж — это строка в таблице. Для поиска по строкам (кортежам) используется ключевое слово WHERE, после которого перечисляются условия на кортежи данных.


## HAVING
Если ключевое слово WHERE определяет фильтрацию строк, то ключевое слово HAVING применяется после группировки (GROUP BY) для определения аналогичной фильтрации, но по значениям агрегатных функций в группах.

Это необходимо для проверки значений, которые получены с помощью агрегатной функции не из отдельных строк источника записей, определенного в предложении FROM, а из групп таких строк. Поэтому такая проверка не может содержаться в предложении WHERE.

В самом SELECT не обязательно указывать агрегатную функцию, которая используется в HAVING. Также заметим, что в предложении HAVING нельзя использовать псевдоним (например, books_count), используемый для именования значений агрегатной функции в предложении SELECT, так как обработка названий столбцов для вывода на экран производится позже, чем фильтрация значений агрегатных функций.

Например, если мы хотим получить список самых плодовитых авторов, которые написали больше 10 книг, мы можем написать:
```sql
select author 
from books 
group by author 
having count(book_id) > 10;
```

Условия в HAVING можно комбинировать так же, как и в WHERE, то есть с использованием скобок, and и or:
```sql
select author, count(book_id) books_count
from books 
group by author 
having count(book_id) > 10 and avg(book_average_rating) > 3.8;
```

## ORDER BY - Сортировка данных
Ключевое слово `ORDER BY` используется для сортировки данных. Оно указывается в самом конце запроса (если в запросе нет LIMIT или OFFSET). После `ORDER BY` через запятую передаются названия колонок, по которым должна проходить сортировка. Сортировка тяжелая операция, поэтому лишний раз ее не использовать. Желательно для наглядности использовать `ORDER BY` даже если не просят.
- `order by population` - упорядочить по увеличению в колонке population
- `order by population desc` - упорядочить в обратном порядке в колонке population
- `asc` - упорядочить по возрастанию (по умолчанию значение; на практике никто никогда не пишет)
- `desc` - упорядочить по убыванию (из логики более важная сортировка, т.к. большие значения будут вверху)


Пример:
```sql
select author, book_name, publishing_year 
from books 
where publishing_year > 1980 
order by author desc, book_name desc -- для каждой колонки указывается тип сортировки
```
Если в ORDER BY выбрано несколько полей, то сортировка идёт последовательно: сначала по первому столбцу, а если значения в этом столбце одинаковые, то сортировка идёт по следующему столбцу и так далее.

### Упрощение работы с ORDER BY
Для упрощения работы с ORDER BY можно использовать не названия столбцов, а номер столбца в выгружаемых данных. Например:
```sql
select author, book_id
from books
order by 2;
```
Этот запрос выведет список авторов и ID их книг, отсортированный по второй колонке в запросе, то есть по book_id.

Также в ORDER BY помимо параметра `desc/asc` можно передавать параметр `NULLS FIRST / NULLS LAST`, который показывает, в начало списка или в конец ставить пустые значения сортируемой колонки.

Для упрощения работы с ORDER BY можно использовать не названия столбцов, а номер столбца в выгружаемых данных. Этот запрос выведет список авторов и ID их книг, отсортированный по второй колонке в запросе, то есть по book_id. Например:
```sql
select author, book_id
from books
order by 2;
```

Также в `ORDER BY` помимо параметра desc/asc можно передавать параметр `NULLS FIRST` / `NULLS LAST`, который показывает, в начало списка или в конец ставить пустые значения сортируемой колонки.

```sql
select author, language_code, book_id
from books
where author = 'Ally Condie'
order by author, language_code asc nulls first;
```

## LIMIT И OFFSET - Ограничения
Иногда нам нужны не все данные по каким-то условиям, а лишь их часть. Например, когда нужно посмотреть, что и в каком формате содержится в таблице. С этим могут помочь ключевые слова LIMIT и OFFSET.

- `LIMIT` и `OFFSET` можно использовать вместе, их порядок не важен.
- `LIMIT`, и `OFFSET` всегда пишутся в самом конце запроса.
- `LIMIT` - используется для вывода строк, например `limit 5` - выводит 5 строк. Особенно удобно использовать, когда только знакомишься с новой БД и не знаешь ее объем и как она устроена
- `OFFSET` - используется для обрезания строк "сколько пропустить", например `OFFSET 5` - обрежет 5 строк

Допустим, нам нужно вывести 5 строк таблицы. Нам поможет слово LIMIT.
```sql
select * 
from books 
limit 5;
```

```sql
-- вывести третий город по количеству населения в штате Техас
select * 
FROM sql.city 
where state = 'Texas'
ORDER BY population desc
limit 1 offset 2
```

```sql
-- вывести сначала невалидные значение (значение которых Null)
select city_name
, population/nullif((area-1.3), 0)
FROM sql.city 
order by population/nullif((area-1.3), 0) nulls first
limit 15 
```

```sql
-- выкинуть невалидные значение (значение которых Null)
select city_name
, population/nullif((area-1.3), 0)
FROM sql.city 
where population/nullif((area-1.3), 0) is not null
order by population/nullif((area-1.3), 0)
limit 15 
```

## LIKE
ВЫборка данных по строкам

- `LIKE` используется для сравнения строк. В отличие от операторов отношения равно `(=)` и не равно `(<>)`, `LIKE` позволяет сравнивать строки не на полное совпадение (не совпадение), а в соответствии с шаблоном. Шаблон может включать обычные символы и символы-шаблоны. При сравнении с шаблоном, его обычные символы должны в точности совпадать с символами, указанными в строке. Символы-шаблоны могут совпадать с произвольными элементами символьной строки. Чувствителен к регистру. Тяжелый, долго обрабатывается, если можно не использовать, то лучше не использовать.
- `ILIKE` - тоже самое что и `LIKE`, только не чувствителен к регистру.
- `%` (означает все что угодно) заменяет любое количество символов (включая ноль). `SELECT * FROM book WHERE author LIKE '%М.%'` выполняет поиск и выдает все книги, инициалы авторов которых содержат «М.»
- `_` заменяет ровно один символ. `SELECT * FROM book WHERE title LIKE 'Поэм_'` выполняет поиск и выдает все книги, названия которых либо «Поэма», либо «Поэмы» и пр. В реале пактически не используется.

Вывести названия книг, начинающихся с буквы «Б». Строчные и прописные буквы в строках эквивалентны.
```sql
SELECT title 
FROM book
WHERE title LIKE 'Б%';
/* эквивалентное условие 
title LIKE 'б%'
*/
```
+-------------------+
| title             |
+-------------------+
| Белая гвардия     |
| Братья Карамазовы |
+-------------------+

Вывести название книг, состоящих ровно из 5 букв. Для обозначения одного любого символа используется  "_", следовательно для обозначения 5 символов используется 5 подряд символов подчеркивания.
```sql
SELECT title FROM book 
WHERE title LIKE "_____"
```
+-------+
| title |
+-------+
| Идиот |
| Поэмы |
+-------+

Вывести книги, название которых длиннее 5 символов:
**Пояснение**: Для того чтобы вывести названия, состоящие из любого количества символов после `LIKE` можно использовать шаблон `"%"`, с помощью которого отбираются строки, состоящие из любого количества символов, в том числе и "пустые", поскольку % заменяет любое количество символов, в том числе и нулевое.

Чтобы указать, что в названии должен быть хотя бы один символ, можно использовать один из эквивалентных шаблонов:

`"_%"` - сначала идет символ, а за ним любое количество символов;
`"%_"` - сначала идет любое количество символов, а затем обязательный символ;
`"%_%"` - сначала идет любое количество символов, потом обязательный символ, а за ним любое количество символов.

```sql
SELECT title FROM book 
WHERE title LIKE "______%";
/* эквивалентные условия 
title LIKE "%______"
title LIKE "%______%"
*/
```
+-----------------------+
| title                 |
+-----------------------+
| Мастер и Маргарита    |
| Белая гвардия         |
| Братья Карамазовы     |
| Стихотворения и поэмы |
| Дети полуночи         |
| Лирика                |
| Капитанская дочка     |
+-----------------------+

Вывести названия книг, которые содержат букву "и" как отдельное слово, если считать, что слова в названии отделяются друг от друга пробелами и не содержат знаков препинания.
**Пояснение:** 
Слово "и" может располагаться в названии в следующих позициях (при условии, что слова отделяются друг от друга пробелами):
- в середине -  "_% и _%" - сначала идет любое количество символов (один обязательный), потом обязательный пробел, а за ним "и", снова обязательный пробел, и наконец любое количество символов (один обязательный);
- в начале - "и _%" - сначала идет "и", обязательный пробел и любое количество символов (один обязательный);
- в конце - "_% и" - сначала идет любое количество символов, затем обязательный пробел и буква "и":
- одно слово в названии - "и".
Вместо "_%" можно использовать эквивалентные шаблоны "%_" и "%_%" .

В качестве обязательного символа ( "_"), может быть и пробел, но, к сожалению, шаблоны для LIKE не позволяют исключить какой-то символ. Это можно сделать только с помощью регулярных выражений (будут рассмотрены в уроке 3.5)
```sql
SELECT title FROM book 
WHERE   title LIKE "_% и _%" /*отбирает слово И внутри названия */
    OR title LIKE "и _%" /*отбирает слово И в начале названия */
    OR title LIKE "_% и" /*отбирает слово И в конце названия */
    OR title LIKE "и" /* отбирает название, состоящее из одного слова И */
```
+-----------------------+
| title                 |
+-----------------------+
| Мастер и Маргарита    |
| Стихотворения и поэмы |
+-----------------------+

Вывести названия книг, которые состоят ровно из одного слова, если считать, что слова в названии отделяются друг от друга пробелами.
**Пояснение**
Отсутствие пробела в названии означает, что оно состоит из одного слова. Чтобы это проверить используется оператор NOT LIKE, который в данном случае отберет все названия, в которых нет пробелов.
```sql
SELECT title FROM book 
WHERE title NOT LIKE "% %";
```
+--------+
| title  |
+--------+
| Идиот  |
| Лирика |
| Поэмы  |
+--------+


## DISTINCT
Иногда нужны не все данные из таблицы, а только уникальные значения в столбце (другими словами разные). Например, мы хотим получить всех авторов книг в таблице books.

Для этого может использоваться команда DISTINCT
```sql
-- Такой запрос выведет только уникальных авторов из таблицы.
select distinct author
from books
order by author;
```

DISTINCT можно применять не только к одному столбцу, но и к нескольким сразу, тогда будут получены все уникальные комбинации столбцов в этих строках:

```sql
-- В этом случае запрос вывел все уникальные пары автор-год публикации книги.
select distinct author, publishing_year
from books
order by author, publishing_year;
```

DISTINCT можно применять не только для вывода уникальных значений, но и внутри агрегатных функций для того, чтобы они применялись только к уникальным элементам определённых столбцов.

```sql
-- посчитать количество авторов в нашей базе
select count(distinct author) as authors_count
from books;
```

## GROUP BY
**!!!! в GROUP BY попадает все, что не попало в агрегацию - простое правило !!!!**
GROUP BY используется для определения групп выходных строк, к которым могут применяться агрегатные функции (COUNT, MIN, MAX, AVG и SUM).
```sql
select publishing_year, count(book_id)
from books
where publishing_year >= 2010
group by publishing_year 
order by publishing_year desc;
```
Здесь мы сначала выделили только те книги, у которых год публикации больше или равен 2010, затем сгруппировали оставшиеся строки по publishing_year (отдельная группа для каждого publishing_year), потом посчитали количество книг (book_id) в каждой группе, а затем отсортировали по publishing_year по убыванию.

`GROUP BY можно использовать и без агрегатных функций. Тогда его действие будет равносильно действию DISTINCT.`
```sql
select publishing_year
from books
group by publishing_year
order by publishing_year

select distinct publishing_year
from books
order by publishing_year
```

`GROUP BY можно использовать для любого количества столбцов (комбинаций столбцов) таблицы. Например, если мы хотим получить средние оценки и количество книг, вышедших с 2005 до 2010 года, в разбивке по жанру и году публикации книги, и отсортировать по убыванию по средней оценки книги в группе, мы можем написать так.`

`При использовании GROUP BY сортировка по столбцам вне выдачи невозможна. То есть в случае с последним запросом мы могли бы отсортировать данные только по genre, publishing_year, books_rating, books_count, а по колонке author уже не смогли бы.`

Для указания столбцов, по которым нужно производить группировку, можно использовать номера столбцов из select (по аналогии с order by) и по алиасам столбцов:
```sql
select author, publishing_year > 1950 after_fifties, count(book_id)
from books
group by 1, after_fifties;
```

## EXISTS
Cинтаксис SQL позволяет непосредственно в разделе where обращаться к полям другой таблицы. 
`EXISTS` - возвращает true, если результатом запроса является хотя бы одна строка, и false, если не существует ни одной.




## EXTRACT
```sql
SELECT
    EXTRACT(MONTH FROM o.order_date) AS order_month,
    COUNT(*) AS cnt
FROM
    other.book_orders AS o
JOIN
    other.books AS b ON o.book_id = b.book_id
WHERE
    b.publishing_year >= 2021 - 10
    AND o.order_date >= '2019-01-01'
GROUP BY
    order_month
ORDER BY
    order_month DESC;
```

# INSERT
```sql
/* чтобы проверить запрос, добавьте в таблицу строку */
INSERT INTO book (title, author, price, amount) VALUES ('Черный человек','Есенин С.А.', Null, Null);

SELECT author, COUNT(author), COUNT(amount), COUNT(*)
FROM book
GROUP BY author;
```
 
# Математические функции
`CEILING(x)` - возвращает наименьшее целое число, большее или равное x (округляет до целого числа в большую сторону), прмиер 
```sql
CEILING(4.2)=5
CEILING(-5.8)=-5
```

`ROUND(x, k)` -округляет значение x до k знаков после запятой, если k не указано – x округляется до целого, пример 
```sql
ROUND(4.361)=4
ROUND(5.86592,1)=5.9
```

`FLOOR(x)` -возвращает наибольшее целое число, меньшее или равное x (округляет до  целого числа в меньшую сторону), пример
```sql
FLOOR(4.2)=4
FLOOR(-5.8)=-6
```

`POWER(x, y)`	-возведение x в степень y, пример
```sql
POWER(3,4)=81.0
```

`SQRT(x)`квадратный корень из x	
```sql
SQRT(4)=2.0
SQRT(2)=1.41...
```

`DEGREES(x)`	конвертирует значение x из радиан в градусы	
```sql
DEGREES(3) = 171.8...
```

`RADIANS(x)`	конвертирует значение x из градусов в радианы	
```sql
RADIANS(180)=3.14...
```

`ABS(x)`	модуль числа x	ABS(-1) = 1
```sql
ABS(1) = 1
```

`PI()`	pi = 3.1415926...

# Агрегатные функции
Суть агрегатной функции в том, что она позволяет вычислить единственное значение, обработав множество строк. Агрегатные функции используются, когда нужно посчитать параметры, общие для всех строк таблицы. Например, есть агрегатные функции, вычисляющие:
- `SUM` -сумма
- `COUNT` - количество не пустых значений
- `AVG` - среднее
- `MIN` - минимум для набора строк
- `MAX` - максимум для набора строк

Важно: агрегатные функции `min`, `max`, `count` можно использовать и для строковых типов данных, и для даты-времени.

**Синтаксис**:
```sql
SELECT Агрегация(над чем)
FROM Таблица
```
```sql
select max(book_average_rating) as max_rating 
from books;
-- max_rating 4.77777
```
```sql
select max(book_average_rating) as max_rating
	, min(book_average_rating) as min_rating
	, avg(book_average_rating) as average_rating
	, sum(book_ratings_count) as books_ratings
from books;
-- вывод 4 колонки с результатами
```
```sql
select max(book_average_rating) as max_rating
	, min(book_average_rating) as min_rating
	, avg(book_average_rating) as average_rating
	, sum(book_ratings_count) as books_ratings
	, count(book_id) as books_count
from books
where language_code = 'eng'; -- c дополнительным условием - фильтром
-- вывод 5 колонок и 1 строка
```




```sql
select sum(hp) sum_hp -- сложить все значения в колонке hp
from sql.pokemon
-- результат 55407
```

При запросе с агрегатными функциями можно использовать условия на строки (WHERE).
```sql
select avg(attack) attack_avg
from sql.pokemon
WHERE type1 = 'Dark'
-- результат 88.39
```

Пример использования всех агрегатных функций:
```sql
select max(book_average_rating) as max_rating
	, min(book_average_rating) as min_rating
	, avg(book_average_rating) as average_rating
	, sum(book_ratings_count) as books_ratings
	, count(book_id) as books_count
from books
where language_code = 'eng
```
Для подсчёта количества непустых строк можно использовать count(*):
```sql
select count(*) not_null_strings_count
from books
```


## Выборка данных, вычисляемые столбцы, логические функции
В SQL реализована возможность заносить в поле значение в зависимости от условия. Для этого используется функция IF():
`IF(логическое_выражение, выражение_1, выражение_2)`
Функция вычисляет логическое_выражение, если оно истина – в поле заносится значение `выражения_1`, в противном случае –  значение `выражения_2`. Все три параметра `IF()` являются обязательными.

Допускается использование вложенных функций, вместо `выражения_1` или `выражения_2` может стоять новая функция `IF`.

Для каждой книги из таблицы book установим скидку следующим образом: если количество книг меньше 4, то скидка будет составлять 50% от цены, в противном случае 30%.
```sql
SELECT title, amount, price, 
    IF(amount<4, price*0.5, price*0.7) AS sale
FROM book;
```
+-----------------------+--------+--------+---------+
| title                 | amount | price  | sale    |
+-----------------------+--------+--------+---------+
| Мастер и Маргарита    | 3      | 670.99 | 335.495 |
| Белая гвардия         | 5      | 540.50 | 378.350 |
| Идиот                 | 10     | 460.00 | 322.000 |
| Братья Карамазовы     | 2      | 799.01 | 399.505 |
| Стихотворения и поэмы | 15     | 650.00 | 455.000 |
+-----------------------+--------+--------+---------+

Цена по скидке должна отображаться с двумя знаками после запятой, добавим в запрос округление:
```sql
SELECT title, amount, price, 
    ROUND(IF(amount<4, price*0.5, price*0.7),2) AS sale
FROM book;
```

+-----------------------+--------+--------+--------+
| title                 | amount | price  | sale   |
+-----------------------+--------+--------+--------+
| Мастер и Маргарита    | 3      | 670.99 | 335.50 |
| Белая гвардия         | 5      | 540.50 | 378.35 |
| Идиот                 | 10     | 460.00 | 322.00 |
| Братья Карамазовы     | 2      | 799.01 | 399.51 |
| Стихотворения и поэмы | 15     | 650.00 | 455.00 |
+-----------------------+--------+--------+--------+


Если количество книг меньше 4 , то скидка составляет 50%, для остальных книг, количество которых меньше 11, скидка 30%, для всех оставшихся – 10%. И еще укажем какая именно скидка на каждую книгу.
```sql
SELECT title, amount, price,
    ROUND(
     IF(amount < 4, price * 0.5, 
         IF(amount < 11, price * 0.7, price * 0.9)),
     2) AS sale,
    IF(amount < 4, 'скидка 50%', 
      IF(amount < 11, 'скидка 30%', 'скидка 10%')
     ) AS Ваша_скидка
FROM book;
```

+-----------------------+--------+--------+--------+-------------+
| title                 | amount | price  | sale   | Ваша_скидка |
+-----------------------+--------+--------+--------+-------------+
| Мастер и Маргарита    | 3      | 670.99 | 335.50 | скидка 50%  |
| Белая гвардия         | 5      | 540.50 | 378.35 | скидка 30%  |
| Идиот                 | 10     | 460.00 | 322.00 | скидка 30%  |
| Братья Карамазовы     | 2      | 799.01 | 399.51 | скидка 50%  |
| Стихотворения и поэмы | 15     | 650.00 | 585.00 | скидка 10%  |
+-----------------------+--------+--------+--------+-------------+

## Выборка данных по условию
Вывести название и цену тех книг, цены которых меньше 600 рублей.

```sql
SELECT title, price 
FROM book
WHERE price < 600;
```
+---------------+--------+
| title         | price  |
+---------------+--------+
| Белая гвардия | 540.50 |
| Идиот         | 460.00 |
+---------------+--------+
В логическом выражении после `WHERE` нельзя использовать названия столбцов, присвоенные им с помощью `AS`, так как при выполнении запроса сначала вычисляется логическое выражение для каждой строки исходной таблицы, выбираются строки, для которых оно истинно. А только после этого формируется "шапка запроса" – столбцы, включаемые в запрос.


## Выборка данных, логические операции
 Логическое выражение после ключевого слова WHERE кроме операторов сравнения  и выражений может включать  логические операции (И «and», ИЛИ «or», НЕ «not») и круглые скобки, изменяющие приоритеты выполнения операций.

**Приоритеты операций:**
1. круглые скобки
2. умножение  (*),  деление (/)
3. сложение  (+), вычитание (-)
4. операторы сравнения (=, >, <, >=, <=, <>)
5. NOT
6. AND
7. OR

Вывести название, автора и цену тех книг, которые написал Булгаков, ценой больше 600 рублей
```sql
SELECT title, author, price 
FROM book
WHERE price > 600 AND author = 'Булгаков М.А.';
```
+--------------------+---------------+--------+
| title              | author        | price  |
+--------------------+---------------+--------+
| Мастер и Маргарита | Булгаков М.А. | 670.99 |
+--------------------+---------------+--------+

Вывести название, цену  тех книг, которые написал Булгаков или Есенин, ценой больше 600 рублей. В данном запросе обязательно нужно поставить скобки, так как без них сначала вычисляется  author = 'Есенин С.А.' and price > 600, а потом уже выражение через or. Без скобок были бы отобраны все книги Булгакова и те книги Есенина, цена которых больше 600.
```sql
SELECT title, author, price 
FROM book
WHERE (author = 'Булгаков М.А.' OR author = 'Есенин С.А.') AND price > 600;
```
+-----------------------+---------------+--------+
| title                 | author        | price  |
+-----------------------+---------------+--------+
| Мастер и Маргарита    | Булгаков М.А. | 670.99 |
| Стихотворения и поэмы | Есенин С.А.   | 650.00 |
+-----------------------+---------------+--------+


## Выборка данных, операторы BETWEEN, IN
Логическое выражение после ключевого слова `WHERE` может включать операторы  `BETWEEN` и `IN`. Приоритет  у этих операторов такой же как у операторов сравнения, то есть они выполняются раньше, чем `NOT`, `AND`, `OR`.

Выбрать названия и количества тех книг, количество которых от 5 до 14 включительно.
```sql
SELECT title, amount 
FROM book
WHERE amount BETWEEN 5 AND 14;
```
+---------------+--------+
| title         | amount |
+---------------+--------+
| Белая гвардия | 5      |
| Идиот         | 10     |
+---------------+--------+

Этот запрос можно реализовать по-другому, результат будет точно такой же.
```sql
SELECT title, amount 
FROM book
WHERE amount >= 5 AND amount <=14;
```
Оператор  `IN`  позволяет выбрать данные, соответствующие значениям из списка.

Выбрать названия и цены книг, написанных Булгаковым или Достоевским.
```sql
SELECT title, price 
FROM book
WHERE author IN ('Булгаков М.А.', 'Достоевский Ф.М.');
```
+--------------------+--------+
| title              | price  |
+--------------------+--------+
| Мастер и Маргарита | 670.99 |
| Белая гвардия      | 540.50 |
| Идиот              | 460.00 |
| Братья Карамазовы  | 799.01 |
+--------------------+--------+
Этот запрос можно реализовать по-другому, результат будет точно такой же.
```sql
SELECT title, price 
FROM book
WHERE author = 'Булгаков М.А.' OR author = 'Достоевский Ф.М.';
```

## Выборка данных с сортировкой
При выборке можно указывать столбец или несколько столбцов, по которым необходимо отсортировать отобранные строки. Для этого используются ключевые слова `ORDER BY`, после которых задаются имена столбцов. При этом строки сортируются по первому столбцу. Если указан второй столбец, сортировка осуществляется только для тех строк, у которых значения первого столбца одинаковы. По умолчанию ORDER BY выполняет сортировку по возрастанию. Чтобы управлять направлением сортировки вручную, после имени столбца указывается ключевое слово `ASC` (по возрастанию) или `DESC` (по убыванию). 

Столбцы после ключевого слова `ORDER BY` можно задавать:
- названием столбца;
- номером столбца;
- именем столбца (указанным после `AS`).

Вывести название, автора и цены книг. Информацию  отсортировать по названиям книг в алфавитном порядке.
```sql
SELECT title, author, price
FROM book
ORDER BY title;
```
+-----------------------+------------------+--------+
| title                 | author           | price  |
+-----------------------+------------------+--------+
| Белая гвардия         | Булгаков М.А.    | 540.50 |
| Братья Карамазовы     | Достоевский Ф.М. | 799.01 |
| Идиот                 | Достоевский Ф.М. | 460.00 |
| Мастер и Маргарита    | Булгаков М.А.    | 670.99 |
| Стихотворения и поэмы | Есенин С.А.      | 650.00 |
+-----------------------+------------------+--------+

Аналогичный результат получится при использовании запроса:
```sql
SELECT title, author, price
FROM book
ORDER BY 1;
```

Вывести автора, название и количество книг, в отсортированном в алфавитном порядке по автору и по убыванию количества, для тех книг, цены которых меньше 750 рублей.
```sql
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, amount DESC;
```
+------------------+-----------------------+------------+
| author           | title                 | Количество |
+------------------+-----------------------+------------+
| Булгаков М.А.    | Белая гвардия         | 5          |
| Булгаков М.А.    | Мастер и Маргарита    | 3          |
| Достоевский Ф.М. | Идиот                 | 10         |
| Есенин С.А.      | Стихотворения и поэмы | 15         |
+------------------+-----------------------+------------+

Можно использовать другие варианты записи запроса:
```sql
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, Количество DESC;
```
```sql
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY 1, 3 DESC;
```
Важно! Если названия столбцов заключены в кавычки, то при использовании их в сортировке, необходимо записывать их БЕЗ КАВЫЧЕК.


# Связи
## information_schema.tables
это список всех таблиц.

С помощью такого запроса мы можем увидеть список всех таблиц, относящихся к нашему датасету.
```sql
select 
    t.table_schema,
    t.table_name
from 
    information_schema.tables t
where 
    t.table_schema = 'shipping'
```
```sql
select 
    count(t.table_schema)
from 
    information_schema.tables t
where 
    t.table_schema = 'public'
```

**Имя**	                        **Тип данных**	**Описание**
table_catalog	                sql_identifier	Имя базы данных, содержащей таблицу (всегда текущая база)
table_schema	                sql_identifier	Имя схемы, содержащей таблицу
table_name	                    sql_identifier	Имя таблицы
table_type	                    character_data	Тип таблицы: BASE TABLE для постоянных базовых таблиц (таблиц обычного типа), VIEW для представлений, FOREIGN TABLE для сторонних таблиц, либо LOCAL TEMPORARY для временных таблиц
self_referencing_column_name	sql_identifier	Относится к функциональности, отсутствующей в PostgreSQL
reference_generation	        character_data	Относится к функциональности, отсутствующей в PostgreSQL
user_defined_type_catalog	    sql_identifier	Если таблица является типизированной, это имя базы данных, содержащей нижележащий тип данных (всегда текущая база), иначе NULL.
user_defined_type_schema	    sql_identifier	Если таблица является типизированной, это имя схемы, содержащей нижележащий тип данных, иначе NULL.
user_defined_type_name	        sql_identifier	Если таблица является типизированной, это имя типа данных, иначе NULL.
is_insertable_into	            yes_or_no	YES, если в эту таблицу можно добавлять данные, или NO в противном случае (Базовые таблицы всегда допускают добавление данных, но представления — не обязательно.)
is_typed	                    yes_or_no	YES, если эта таблица является типизированной, иначе NO
commit_action	                character_data	Ещё не реализовано

## information_schema.columns
можно посмотреть данные обо всех столбцах в таблицах, их типах и свойствах

С помощью такого запроса мы можем увидеть список всех полей и их типов в таблице city в схеме shipping.
```sql
select 
    c.table_schema,
    c.table_name,
    c.column_name,
    c.data_type,
    c.ordinal_position
from 
    information_schema.columns c
where 
    c.table_schema = 'shipping'
    and c.table_name = 'city'
```

##  information_schema.table_constraints
Последняя таблица, которая нам будет интересна в рамках этого блока — таблица, в которой хранится информация о первичных и внешних ключах в таблицах. С помощью такого запроса мы можем увидеть все ключи таблицы shipment нашего датасета.
```sql
select 
    c.table_schema,
    c.table_name,
    c.constraint_name,
    c.constraint_type
from 
    information_schema.table_constraints c
where 
    c.table_schema = 'shipping'
    and c.table_name = 'shipment'
    and c.constraint_type in ('PRIMARY KEY','FOREIGN KEY')
```

# JOIN
JOIN — это оператор для выполнения соединений. Его нужно писать в разделе from между таблицами, которые вы планируете соединить. Оператор JOIN позволяет добавить к кортежам одной таблицы кортеж другой.

```sql
from table1 t1 
join table2 t2 
on t1.id = t2.fk_id 
-- Это значит, что к таблице t1 мы присоединяем таблицу t2, к записям из t1 присоединяем только те из t2, в которых fk_id соответствует id из t1.

select 	*
from
    shipping.shipment s
        join shipping.driver d on s.driver_id = d.driver_id
```

Объединив две таблицы, мы можем обращаться ко всем их столбцам в любом порядке.
```sql
select 	
    s.ship_id, 
    d.last_name,
    s.truck_id,
    d.phone
from
    shipping.shipment s
        join shipping.driver d on s.driver_id = d.driver_id
```

Существует два основных вида соединения таблиц — внутреннее и внешнее (INNER и OUTER).
- `Внутреннее соединение (INNER JOIN)` подразумевает, что в результате останутся кортежи из обеих таблиц, удовлетворяющие условию соединения; остальные будут отброшены
- `Внешнее соединение`: LEFT, RIGHT, FULL
    - `LEFT` - В случае LEFT JOIN сохранятся все кортежи левой таблицы (той, которая написана слева от join). Кортежи из правой таблицы присоединяются только при выполнении условий. Те кортежи правой таблицы, которых нет в левой, отбрасываются.
    - `RIGHT` - RIGHT JOIN происходит ровно так же, только за основу берется правая таблица. Чтобы из LEFT JOIN получить RIGHT JOIN, нужно просто поменять порядок таблиц в запросе.

Таблицы можно соединять не только по первичным ключам `id`, но также используя `>`, `<`, `=`

Соединения бывают двух типов:
1. Справочники - на примере города
2. Расшифровки (конкретизация, детализация) - пример чек и покупки

Синтаксис:
```sql
select имена_столбцов
from имя_таблицы_1
join имя_таблицы_2 on условия
```

Пример
```sql
select *
from customer
join ordersum
on ordersum.customerid = customer.customerid
```

## INNER
### УСЛОВИЕ РАВЕНСТВА
Для соединения таблиц чаще всего используются их ключи. Например, таблица shipping.shipment связана с таблице shipping.driver по полю driver_id, то есть для их соединения нужно указать условие равенства полей driver_id в обеих таблицах.
```sql
select 	*
from
    shipping.shipment s
        join shipping.driver d on s.driver_id = d.driver_id
```

### УКАЗАНИЕ ИМЕНИ
Объединив две таблицы, мы можем обращаться ко всем их столбцам в любом порядке.
```sql
select 	
    s.ship_id, 
    d.last_name,
    s.truck_id,
    d.phone
from
    shipping.shipment s
        join shipping.driver d on s.driver_id = d.driver_id
```

### ГРУППИРОВКА И СОРТИРОВКА
После объединения таблиц можно использовать все уже изученные функции группировки и сортировки:
```sql
select 	
    d.last_name,
    count(distinct s.city_id) uniq_cities
from
    shipping.shipment s
        join shipping.driver d on s.driver_id = d.driver_id
group by d.last_name
order by count(distinct s.city_id) desc
limit 5
offset 1
```

### СОЕДИНЕНИЕ БОЛЕЕ ДВУХ ТАБЛИЦ
```sql
select 
    s.ship_date,
    t.model_year,
    c.city_name,
    count(*) shipments
from 
    shipping.shipment s
        join shipping.truck t on s.truck_id = t.truck_id
        join shipping.city c on s.city_id = c.city_id
group by     
    s.ship_date,
    t.model_year,
    c.city_name
```

## OUTER JOIN. Виды
Помимо внутреннего соединения существует внешнее соединение — OUTER JOIN.

Синтаксически он ничем не отличается от INNER JOIN

### LEFT
В случае LEFT JOIN сохранятся все кортежи левой таблицы (той, которая написана слева от join). Кортежи из правой таблицы присоединяются только при выполнении условий. Те кортежи правой таблицы, которых нет в левой, отбрасываются.
**Зачем нужен LEFT**
- Первое и основное — подтянуть данные к основной таблице из другой таблицы, в которой данных может и не быть.
- Также он применяется при желании проверить, что не существует записей, «связанных» с левой таблицей. Например, используя LEFT JOIN и проверку IS NULL, можно найти клиентов, которые никогда не совершали заказ.

```sql
select 
    c.cust_id
from 
    shipping.customer c 
    left join shipping.shipment s on c.cust_id = s.cust_id
where s.ship_id is null
```

### FULL OUTER JOIN
В каких случаях чаще всего встречается FULL OUTER JOIN?
- Когда схема данных недостаточно нормализованна и нет единых справочников. По сути этот оператор объединяет LEFT и RIGHT JOIN и позволяет сохранить все кортежи из обеих таблиц, связать удовлетворяющие условиям и оставить пустыми кортежи, для которых не нашлось связных.

```sql
select 
    coalesce(c.zip,d.zip_code) zip,
    count(distinct c.cust_id) customers,
    count(distinct d.driver_id) drivers
from 
    shipping.customer c
        full outer join shipping.driver d on c.zip = d.zip_code
group by 1
having count(distinct c.cust_id) + count(distinct d.driver_id) >0
order by  count(distinct c.cust_id) + count(distinct d.driver_id)  desc
```

`СOALESCE` возвращает первый попавшийся аргумент, отличный от NULL. Если же все аргументы равны NULL, результатом тоже будет NULL. Это часто используется при отображении данных для подстановки некоторого значения по умолчанию вместо значений NULL.

В данном примере, если будет заполнен столбец c.zip, то будет взят он, если же значение c.zip пустое (NULL), то будет взято значение d.zip_code, даже если оно пустое:
```sql
coalesce(c.zip,d.zip_code) zip
```

А в этом примере, если значение d.zip_code будет пустым, то будет подставлено значение 123456 — оно будет значением по умолчанию:
```sql
coalesce(c.zip,d.zip_code,'123456') zip
```

### CROSS JOIN

Данным запросом к каждой записи водителя мы присоединим все записи с клиентами.
```sql
select 
    *
from 
    shipping.driver 
        cross join shipping.customer
```

Альтернативным синтаксисом для CROSS JOIN является просто указание всех таблиц в разделе from через запятую. Это устаревший формат, так как он имеет низкую читабельность. Тем не менее такой синтаксис поддерживается большинством СУБД.
```sql
select 
    *
from 
    shipping.driver,shipping.customer
```

### USING
используется для упрощения синтаксиса при объединении таблиц, у которых одинаковое имя столбца
```sql
select city_name, population
from pop
join dens using(city_id) --on dens.city_id = pop.city_id
```